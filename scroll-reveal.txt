clase para q se muestre en contenido: scroll-reveal
ejemplo: <section class="... scroll-reveal">


css:
/* css/smooth-reveal.css */

/*
 * Estilos para el efecto "Smooth Reveal" (aparición suave al hacer scroll).
 * Utiliza transform y opacity para animaciones fluidas, elegantes y con propósito.
 */

/* Desplazamiento suave global para toda la página (complemento al JS) */
html {
    /* Mejora la experiencia de usuario al navegar a secciones internas */
    scroll-behavior: smooth;
}

/* 1. Estado inicial oculto */
.scroll-reveal.reveal-hidden {
    opacity: 0;
    /* Inicio de la microanimación: ligeramente desplazado hacia abajo para un efecto "fade up" */
    transform: translateY(30px); 
    /* Transición elegante y natural */
    transition: opacity 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    /* Se usa 'cubic-bezier' para una transición más dinámica y profesional que el 'ease' estándar. */
}

/* 2. Estado revelado (la clase 'revealed' se añade por JavaScript) */
.scroll-reveal.revealed {
    opacity: 1;
    transform: translateY(0); /* Vuelve a su posición original */
}

/* 3. Evitar que el efecto aplique a elementos que deben ser visibles inmediatamente (como el header) */
header .scroll-reveal {
    opacity: 1;
    transform: none;
    transition: none;
}




js:
document.addEventListener('DOMContentLoaded', () => {
    // Usamos la clase 'scroll-reveal'
    const revealElements = document.querySelectorAll('.scroll-reveal');

    // Opciones del observador
    const observerOptions = {
        root: null,
        rootMargin: '0px 0px -10% 0px', 
        threshold: 0.1
    };

    // Callback que se ejecuta cuando la visibilidad de un elemento cambia
    const observerCallback = (entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                // Si el elemento es visible, añade la clase 'revealed' para disparar la animación CSS.
                entry.target.classList.add('revealed');
                // Deja de observar una vez revelado para optimizar el rendimiento.
                observer.unobserve(entry.target);
            }
        });
    };

    // Crear y activar el Intersection Observer
    if ('IntersectionObserver' in window) {
        const observer = new IntersectionObserver(observerCallback, observerOptions);

        revealElements.forEach(element => {
            // Inicialmente, añade la clase 'reveal-hidden' para asegurar el estado inicial (oculto)
            element.classList.add('reveal-hidden');
            observer.observe(element);
        });
    } else {
        // Fallback simple para navegadores sin soporte: muestra todos los elementos inmediatamente.
        revealElements.forEach(element => {
            element.classList.add('revealed');
        });
    }
    
    document.querySelectorAll('a[href^="#"]:not([href="#"])').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            if (this.hash) {
                e.preventDefault();

                const targetElement = document.querySelector(this.hash);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth'
                    });

                    // Actualiza la URL para reflejar la posición (sin recarga)
                    if (history.pushState) {
                        history.pushState(null, null, this.hash);
                    } else {
                        window.location.hash = this.hash;
                    }
                }
            }
        });
    });

});
